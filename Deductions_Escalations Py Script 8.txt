import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import datetime
import numpy as np
import os
import sys
import json
from io import BytesIO, StringIO

# Define themes
THEMES = {
    "Default": {
        "primary_color": "#1E88E5",
        "background_color": "#FFFFFF",
        "text_color": "#424242",
        "accent_color": "#FFC107",
        "secondary_color": "#4CAF50",
        "font": "sans-serif"
    },
    "Dark": {
        "primary_color": "#2962FF",
        "background_color": "#121212",
        "text_color": "#E0E0E0",
        "accent_color": "#FF6D00",
        "secondary_color": "#00C853",
        "font": "sans-serif"
    },
    "Corporate": {
        "primary_color": "#0D47A1",
        "background_color": "#F5F5F5",
        "text_color": "#212121",
        "accent_color": "#E65100",
        "secondary_color": "#2E7D32",
        "font": "serif"
    }
}

# Apply theme
def apply_theme(theme_name):
    if theme_name not in THEMES:
        theme_name = "Default"
    
    theme = THEMES[theme_name]
    
    # Apply CSS with the selected theme
    st.markdown(f"""
<style>
        /* Global Styles */
        .stApp {{
            background-color: {theme["background_color"]};
            color: {theme["text_color"]};
            font-family: {theme["font"]};
        }}
        
        /* Headers */
        h1, h2, h3, h4, h5, h6 {{
            color: {theme["primary_color"]};
            font-family: {theme["font"]};
        }}
        
        /* Main title */
        .main-title {{
            color: {theme["primary_color"]};
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            text-align: center;
            padding: 1.2rem;
            border-bottom: 2px solid {theme["accent_color"]};
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background: linear-gradient(to right, {theme["primary_color"]}15, {theme["accent_color"]}15);
            border-radius: 8px;
        }}
        
        /* Sub titles */
        .sub-title {{
            color: {theme["primary_color"]};
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1.2rem;
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid {theme["accent_color"]}40;
            display: flex;
            align-items: center;
        }}
        
        /* Card Styling */
        .metric-card {{
            background-color: white;
            border-radius: 8px;
            padding: 1.2rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            border-left: 4px solid {theme["primary_color"]};
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }}
        
        .metric-card:hover {{
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }}
        
        .metric-value {{
            font-size: 1.8rem;
            font-weight: 700;
            color: {theme["primary_color"]};
            margin-bottom: 0.3rem;
        }}
        
        .metric-label {{
            font-size: 1rem;
            color: {theme["text_color"]}80;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        
        /* Section styling */
        .dashboard-section {{
            background-color: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }}
        
        /* Upload area styling */
        .upload-container {{
            border: 2px dashed {theme["accent_color"]}50;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            background-color: {theme["accent_color"]}10;
            transition: all 0.3s ease;
        }}
        
        .upload-container:hover {{
            border-color: {theme["accent_color"]};
            background-color: {theme["accent_color"]}15;
        }}
        
        /* Filter styling */
        .filter-container {{
            background-color: {theme["background_color"]};
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            margin-bottom: 1rem;
        }}
        
        /* Button styling */
        .stButton>button {{
            background-color: {theme["primary_color"]};
            color: white;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            font-weight: 500;
            border: none;
            transition: all 0.3s ease;
        }}
        
        .stButton>button:hover {{
            background-color: {theme["primary_color"]}cc;
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
        }}
        
        /* Welcome header */
        .welcome-header {{
            font-size: 1.2rem;
            font-weight: 600;
            color: {theme["primary_color"]};
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid {theme["accent_color"]};
        }}
        
        /* Insights styling */
        .insight-item {{
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.8rem;
            background-color: {theme["background_color"]};
            border-radius: 8px;
            border-left: 3px solid {theme["secondary_color"]};
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }}
        
        .insight-icon {{
            margin-right: 0.75rem;
            color: {theme["secondary_color"]};
            font-size: 1.2rem;
        }}
        
        .insight-content {{
            flex-grow: 1;
        }}
        
        /* Table styling */
        .dataframe {{
            border-collapse: collapse;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        }}
        
        .dataframe th {{
            background-color: {theme["primary_color"]};
            color: white;
            text-transform: uppercase;
            font-size: 0.85rem;
            padding: 0.75rem 1rem;
            letter-spacing: 0.5px;
        }}
        
        .dataframe td {{
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
        }}
        
        .dataframe tr:hover {{
            background-color: {theme["accent_color"]}10;
        }}
    </style>
    """, unsafe_allow_html=True)

# Create session state for user preferences if not exists
if 'theme' not in st.session_state:
    st.session_state['theme'] = "Default"

# Check authentication status
if "authenticated" not in st.session_state or not st.session_state["authenticated"]:
    st.warning("Please log in from the Home page to access this dashboard.")
    st.stop()

# Create a minimal sidebar with just welcome message
with st.sidebar:
    # Debug section (collapsible)
    with st.expander("Debug Info", expanded=False):
        if 'debug_messages' in st.session_state:
            for msg in st.session_state.debug_messages[-10:]:  # Show last 10 messages
                st.text(msg)
        else:
            st.text("No debug messages yet")
            
    # Welcome Message
    st.markdown(f"<div class='welcome-header'>Welcome, {st.session_state.get('username', 'User')}</div>", unsafe_allow_html=True)
    
    # Add a separator
    st.markdown("---")

# Apply the current theme
apply_theme(st.session_state['theme'])

# Initialize session state for storing the dataframe
if 'deductions_df' not in st.session_state:
    st.session_state['deductions_df'] = None
    st.session_state['file_processed'] = False

def debug_print(message):
    """Print debug messages to both console and sidebar if enabled"""
    # Always print to console
    print(f"[DEBUG] {message}")
    
    # Also show in the Streamlit app's debug section
    if 'debug_messages' not in st.session_state:
        st.session_state.debug_messages = []
    st.session_state.debug_messages.append(str(message))
    
    # Keep only the last 20 messages
    if len(st.session_state.debug_messages) > 20:
        st.session_state.debug_messages = st.session_state.debug_messages[-20:]

def convert_to_numeric(series):
    """Helper function to safely convert series to numeric"""
    # If already numeric, return as is
    if pd.api.types.is_numeric_dtype(series):
        return series
    
    # Try to convert to string first to handle any non-string types
    str_series = series.astype(str)
    
    # Remove any non-numeric characters except decimal point and negative sign
    cleaned = str_series.str.replace(r'[^\d.-]', '', regex=True)
    
    # Convert to numeric, coercing errors to NaN
    return pd.to_numeric(cleaned, errors='coerce')

def process_uploaded_file(uploaded_file):
    """Process the uploaded file and return a cleaned dataframe"""
    try:
        # Read the file
        if uploaded_file.name.endswith('.xlsx') or uploaded_file.name.endswith('.xls'):
            df = pd.read_excel(uploaded_file, engine='openpyxl')
        else:
            df = pd.read_csv(uploaded_file)
        
        # Store original columns before any processing
        original_columns = df.columns.tolist()
        debug_print(f"Original columns: {original_columns}")
        
        # First, clean up the column names (just trim whitespace, no title case conversion)
        df.columns = df.columns.str.strip()
        cleaned_columns = df.columns.tolist()
        debug_print(f"Cleaned columns: {cleaned_columns}")
        
        # Define expected columns with possible variations (exact matches)
        column_mapping = {
            "Environment": ["Environment"],
            "Deduction Submission Date": ["Deduction Submission Date"],
            "BranchID": ["BranchID"],
            "Employer": ["Employer"],
            "DepartmentName": ["DepartmentName"],
            "Pay Day": ["Pay Day"],
            "Provider": ["Provider"],
            "Method": ["Method"],
            "Transactions": ["Transactions"],
            "Amount": ["Amount"],
            "Failed Amount": ["Failed Amount"],
            "Failed Department": ["Failed Department"],
            "Status": ["Status"],
            "Escalated To": ["Escalated To"],
            "Successful via Automation": ["Successful via Automation"],
            "Reason": ["Reason"],
            "Remarks": ["Remarks"],
            "Mode": ["Mode"],
            "Task Link / Email Subject": ["Task Link / Email Subject"]
        }
        
        # Create a mapping of cleaned column names to original names
        original_name_map = {col.strip(): col for col in original_columns}
        
        # Map actual columns to expected columns
        column_mapping_inv = {}
        mapped_columns = set()
        
        # First pass: exact matches
        for expected_col, possible_cols in column_mapping.items():
            for col in possible_cols:
                if col in df.columns:
                    column_mapping_inv[col] = expected_col
                    mapped_columns.add(col)
                    debug_print(f"Mapped '{col}' to '{expected_col}' (exact match)")
                    break
        
        # Second pass: case-insensitive matches for any remaining columns
        remaining_columns = [col for col in df.columns if col not in mapped_columns]
        debug_print(f"Remaining unmapped columns: {remaining_columns}")
        
        for col in remaining_columns:
            col_lower = col.lower().replace(" ", "").replace("_", "").replace("-", "")
            for expected_col in column_mapping.keys():
                expected_col_lower = expected_col.lower().replace(" ", "").replace("_", "").replace("-", "")
                if col_lower == expected_col_lower:
                    column_mapping_inv[col] = expected_col
                    mapped_columns.add(col)
                    debug_print(f"Mapped '{col}' to '{expected_col}' (case-insensitive match)")
                    break
        
        # Debug: Print the mapping
        debug_print(f"Column mapping: {column_mapping_inv}")
        
        # Rename columns to standard names
        if column_mapping_inv:
            df = df.rename(columns=column_mapping_inv)
        
        # Check for missing expected columns
        missing_columns = [col for col in column_mapping.keys() if col not in df.columns]
        if missing_columns:
            st.warning(f"Warning: The following columns could not be mapped: {', '.join(missing_columns)}")
            st.info(f"Available columns: {', '.join(original_columns)}")
        
        # Debug: Print final column names
        debug_print(f"Final column names: {df.columns.tolist()}")
        
        # Convert numeric columns
        numeric_columns = ["Amount", "Failed Amount", "Transactions"]
        for col in numeric_columns:
            if col in df.columns:
                df[col] = convert_to_numeric(df[col])
            else:
                debug_print(f"Numeric column not found: {col}")
        
        # Convert date columns
        date_columns = ["Deduction Submission Date", "Pay Day"]
        for col in date_columns:
            if col in df.columns:
                df[col] = pd.to_datetime(df[col], errors='coerce')
            else:
                debug_print(f"Date column not found: {col}")
        
        return df
        
    except Exception as e:
        st.error(f"Error processing file: {str(e)}")
        debug_print(f"Error processing file: {str(e)}")
        return None

def safe_sum(series, default=0):
    """Safely sum a series, handling None and NaN values"""
    if series is None or series.empty or not pd.api.types.is_numeric_dtype(series):
        return default
    return series.sum()

def display_metrics(df):
    """Display key metrics from the dataframe"""
    if df is None or df.empty:
        st.warning("No data available to display metrics.")
        return
    
    # Safely calculate metrics with default values
    total_deductions = safe_sum(df.get('Amount'))
    total_failed = safe_sum(df.get('Failed Amount'))
    
    # Calculate failure rate safely
    if pd.notna(total_deductions) and total_deductions > 0 and pd.notna(total_failed):
        failure_rate = (total_failed / total_deductions) * 100
    else:
        failure_rate = 0.0
    
    # Format values for display
    def format_currency(value):
        try:
            return f"${float(value):,.2f}"
        except (ValueError, TypeError):
            return "$0.00"
    
    # Display metrics in columns with error handling
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown(f"""
        <div class='metric-card'>
            <div class='metric-value'>{format_currency(total_deductions)}</div>
            <div class='metric-label'>Total Deductions</div>
        </div>
        """, unsafe_allow_html=True)
    with col2:
        delta_color = "#EF5350" if failure_rate > 0 else "#66BB6A"
        st.markdown(f"""
        <div class='metric-card'>
            <div class='metric-value'>{format_currency(total_failed)}</div>
            <div class='metric-label'>Failed Amount</div>
            <div style="color: {delta_color}; font-size: 0.9rem; margin-top: 0.5rem;">{failure_rate:.1f}%</div>
        </div>
        """, unsafe_allow_html=True)
    with col3:
        st.markdown(f"""
        <div class='metric-card'>
            <div class='metric-value'>{format_currency(total_deductions / len(df))}</div>
            <div class='metric-label'>Average Amount</div>
        </div>
        """, unsafe_allow_html=True)

def main():
    st.markdown("<h1 class='main-title'>📊 Deductions Escalations Dashboard</h1>", unsafe_allow_html=True)
    
    # File upload section
    st.markdown("<div class='dashboard-section'><h3 class='sub-title'>📤 Upload Deductions Report</h3><div class='upload-container'>", unsafe_allow_html=True)
    uploaded_file = st.file_uploader(
        "Upload your deductions report (Excel or CSV)",
        type=['xlsx', 'xls', 'csv'],
        key="deductions_uploader"
    )
    
    if uploaded_file is not None:
        with st.spinner('Processing file...'):
            # Process the file
            df = process_uploaded_file(uploaded_file)
            
            if df is not None:
                st.session_state['deductions_df'] = df
                st.session_state['file_processed'] = True
                st.success("File processed successfully!")
                
                # Display metrics
                display_metrics(df)
                
                # Show a preview of the data
                st.markdown("</div></div>", unsafe_allow_html=True)
                st.markdown("<div class='dashboard-section'><h3 class='sub-title'>📋 Data Preview</h3>", unsafe_allow_html=True)
                st.dataframe(df.head())
    
    # If we have processed data, show the full dashboard
    if st.session_state.get('file_processed') and st.session_state['deductions_df'] is not None:
        df = st.session_state['deductions_df']
        
        # Add tabs for different views
        tab1, tab2, tab3 = st.tabs(["📊 Overview", "🔍 Transaction Explorer", "📈 Advanced Analytics"])
        
        # Initialize session state for tab navigation
        if 'selected_provider' not in st.session_state:
            st.session_state.selected_provider = None
            st.session_state.force_explorer_refresh = False
        
        def navigate_to_explorer(provider=None):
            st.session_state.selected_provider = provider
            st.session_state.force_explorer_refresh = True
            # Store the current tab to return to after explorer
            st.session_state.previous_tab = "📊 Overview"
        
        with tab1:
            # Use a more modern, cleaner design for the entire Overview tab
            st.markdown("""
            <style>
            .overview-header {
                background: linear-gradient(90deg, #1976D2 0%, #42A5F5 100%);
                color: white;
                padding: 1.5rem;
                border-radius: 12px;
                margin-bottom: 1.5rem;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .overview-title {
                font-size: 1.6rem;
                font-weight: 600;
                margin-bottom: 0.5rem;
            }
            
            .overview-subtitle {
                font-size: 0.9rem;
                opacity: 0.9;
            }
            
            .filter-panel {
                background-color: white;
                padding: 1.2rem;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
                margin-bottom: 1.5rem;
            }
            
            .filter-title {
                font-size: 1rem;
                font-weight: 600;
                color: #42A5F5;
                margin-bottom: 1rem;
                display: flex;
                align-items: center;
            }
            
            .filter-title i {
                margin-right: 0.5rem;
            }
            
            .metric-container {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 1rem;
                margin-bottom: 1.5rem;
            }
            
            .chart-container {
                background-color: white;
                border-radius: 8px;
                padding: 1.2rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
                margin-bottom: 1.5rem;
            }
            
            .chart-title {
                font-size: 1rem;
                font-weight: 600;
                color: #424242;
                margin-bottom: 1rem;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid #f0f0f0;
            }
            
            .pill {
                display: inline-block;
                padding: 0.4rem 0.8rem;
                border-radius: 20px;
                font-size: 0.85rem;
                font-weight: 500;
                margin-right: 0.5rem;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .pill-active {
                background-color: #42A5F5;
                color: white;
            }
            
            .pill-inactive {
                background-color: #f0f0f0;
                color: #424242;
            }
            
            .summary-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1.5rem;
                margin-bottom: 1.5rem;
            }
            
            @media (max-width: 768px) {
                .summary-grid {
                    grid-template-columns: 1fr;
                }
            }
            
            .summary-card {
                background-color: white;
                border-radius: 10px;
                padding: 1.2rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            }
            
            .summary-title {
                font-size: 0.9rem;
                font-weight: 600;
                color: #616161;
                margin-bottom: 1rem;
            }
            
            .summary-items {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
            
            .summary-item-label {
                font-size: 0.85rem;
                color: #757575;
                margin-bottom: 0.3rem;
            }
            
            .summary-item-value {
                font-size: 1.1rem;
                font-weight: 600;
                color: #212121;
            }
            </style>
            
            <div class="overview-header">
                <div class="overview-title">📊 Deductions Overview</div>
                <div class="overview-subtitle">Comprehensive analysis of deductions data</div>
            </div>
            """, unsafe_allow_html=True)
            
            # Summary cards in a 2-column grid layout
            if 'Deduction Submission Date' in df.columns:
                earliest_date = df['Deduction Submission Date'].min().date()
                latest_date = df['Deduction Submission Date'].max().date()
                date_range = (latest_date - earliest_date).days
                
                unique_providers = df['Provider'].nunique() if 'Provider' in df.columns else 'N/A'
                unique_employers = df['Employer'].nunique() if 'Employer' in df.columns else 'N/A'
                total_amount = f"${df['Amount'].sum():,.2f}" if 'Amount' in df.columns else 'N/A'
                avg_amount = f"${df['Amount'].mean():,.2f}" if 'Amount' in df.columns else 'N/A'
                
                st.markdown(f"""
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-title">🔍 Dataset Summary</div>
                        <div class="summary-items">
                            <div>
                                <div class="summary-item-label">Time Range</div>
                                <div class="summary-item-value">{date_range} days</div>
                            </div>
                            <div>
                                <div class="summary-item-label">Total Records</div>
                                <div class="summary-item-value">{len(df):,}</div>
                            </div>
                            <div>
                                <div class="summary-item-label">Providers</div>
                                <div class="summary-item-value">{unique_providers}</div>
                            </div>
                            <div>
                                <div class="summary-item-label">Employers</div>
                                <div class="summary-item-value">{unique_employers}</div>
                            </div>
                        </div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">💵 Financial Summary</div>
                        <div class="summary-items">
                            <div>
                                <div class="summary-item-label">Total Amount</div>
                                <div class="summary-item-value">{total_amount}</div>
                            </div>
                            <div>
                                <div class="summary-item-label">Average Amount</div>
                                <div class="summary-item-value">{avg_amount}</div>
                            </div>
                            <div>
                                <div class="summary-item-label">First Date</div>
                                <div class="summary-item-value">{earliest_date}</div>
                            </div>
                            <div>
                                <div class="summary-item-label">Last Date</div>
                                <div class="summary-item-value">{latest_date}</div>
                            </div>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            # Modern date filter panel
            st.markdown("""
            <div class="filter-panel">
                <div class="filter-title"><i>🗓️</i> Date Range Filter</div>
            </div>
            """, unsafe_allow_html=True)
            
            if 'Deduction Submission Date' in df.columns:
                min_date = df['Deduction Submission Date'].min().date()
                max_date = df['Deduction Submission Date'].max().date()
                
                # Set up the session state for tracking active filter
                if 'date_filter_range' not in st.session_state:
                    st.session_state['date_filter_range'] = 'custom'
                
                # Create pills for quick date selection
                col1, col2 = st.columns([3, 1])
                with col1:
                    st.markdown("""
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                        <div id="pill-30d" class="pill pill-inactive" onclick="setDateRange('30d')">Last 30 Days</div>
                        <div id="pill-90d" class="pill pill-inactive" onclick="setDateRange('90d')">Last Quarter</div>
                        <div id="pill-180d" class="pill pill-inactive" onclick="setDateRange('180d')">Last 6 Months</div>
                        <div id="pill-all" class="pill pill-inactive" onclick="setDateRange('all')">All Time</div>
                    </div>
                    
                    <script>
                    function setDateRange(range) {
                        document.querySelectorAll('.pill').forEach(pill => {
                            pill.classList.remove('pill-active');
                            pill.classList.add('pill-inactive');
                        });
                        document.getElementById('pill-' + range).classList.remove('pill-inactive');
                        document.getElementById('pill-' + range).classList.add('pill-active');
                    }
                    </script>
                    """, unsafe_allow_html=True)
                
                # Add regular buttons since the JavaScript won't work in Streamlit
                quick_filter_col1, quick_filter_col2, quick_filter_col3, quick_filter_col4 = st.columns(4)
                with quick_filter_col1:
                    last_30_days = st.button("Last 30 Days", key="last_30")
                with quick_filter_col2:
                    last_90_days = st.button("Last Quarter", key="last_90")
                with quick_filter_col3:
                    last_180_days = st.button("Last 6 Months", key="last_180")
                with quick_filter_col4:
                    all_time = st.button("All Time", key="all_time")
                
                # Set date range based on quick filter buttons
                today = datetime.datetime.now().date()
                if last_30_days:
                    start_date = max((today - datetime.timedelta(days=30)), min_date)
                    end_date = min(today, max_date)
                    st.session_state['date_filter_range'] = '30d'
                elif last_90_days:
                    start_date = max((today - datetime.timedelta(days=90)), min_date)
                    end_date = min(today, max_date)
                    st.session_state['date_filter_range'] = '90d'
                elif last_180_days:
                    start_date = max((today - datetime.timedelta(days=180)), min_date)
                    end_date = min(today, max_date)
                    st.session_state['date_filter_range'] = '180d'
                elif all_time:
                    start_date = min_date
                    end_date = max_date
                    st.session_state['date_filter_range'] = 'all'
                else:
                    # Use custom range or default values
                    if 'start_date' not in st.session_state or 'end_date' not in st.session_state:
                        start_date = min_date
                        end_date = max_date
                    else:
                        start_date = st.session_state.get('start_date', min_date)
                        end_date = st.session_state.get('end_date', max_date)
                
                # Display calendar pickers in columns
                st.markdown("<div style='margin-top: 1rem; margin-bottom: 0.5rem;'><span style='font-size: 0.9rem; color: #424242;'>Custom Range:</span></div>", unsafe_allow_html=True)
                col1, col2 = st.columns(2)
                with col1:
                    start_date = st.date_input(
                        "Start Date",
                        min_value=min_date,
                        max_value=max_date,
                        value=start_date,
                        key="start_date"
                    )
                with col2:
                    end_date = st.date_input(
                        "End Date",
                        min_value=min_date,
                        max_value=max_date,
                        value=end_date,
                        key="end_date"
                    )
                
                # Filter data by date range
                date_mask = (
                    (df['Deduction Submission Date'].dt.date >= start_date) & 
                    (df['Deduction Submission Date'].dt.date <= end_date)
                )
                filtered_df = df[date_mask].copy()
                
                # Show the active date range
                st.markdown(f"""
                <div style="background-color: #E3F2FD; padding: 0.7rem; border-radius: 8px; margin: 1rem 0; display: flex; align-items: center;">
                    <div style="background-color: #2196F3; width: 12px; height: 12px; border-radius: 50%; margin-right: 0.8rem;"></div>
                    <div>
                        <span style="font-weight: 600; color: #0D47A1;">Active Filter:</span>
                        <span style="color: #1565C0; margin-left: 0.5rem;">{start_date} to {end_date}</span>
                        <span style="background-color: #BBDEFB; color: #0D47A1; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-left: 0.5rem;">{(end_date - start_date).days + 1} days</span>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            else:
                filtered_df = df.copy()
                st.warning("No date column found for filtering")
            
            # Calculate metrics for current period
            total_deductions = filtered_df['Amount'].sum() if 'Amount' in filtered_df.columns else 0
            avg_deduction = filtered_df['Amount'].mean() if 'Amount' in filtered_df.columns else 0
            total_failed = filtered_df['Failed Amount'].sum() if 'Failed Amount' in filtered_df.columns else 0
            failure_rate = (total_failed / total_deductions * 100) if total_deductions > 0 else 0
            total_transactions = len(filtered_df)
            success_count = filtered_df[filtered_df['Status'] == 'Successful'].shape[0] if 'Status' in filtered_df.columns else 0
            success_rate = (success_count / total_transactions * 100) if total_transactions > 0 else 0
            
            # Calculate metrics for previous period (if possible)
            if 'Deduction Submission Date' in filtered_df.columns:
                current_range_days = (end_date - start_date).days + 1
                prev_end_date = start_date - datetime.timedelta(days=1)
                prev_start_date = prev_end_date - datetime.timedelta(days=current_range_days)
                
                prev_mask = (
                    (df['Deduction Submission Date'].dt.date >= prev_start_date) & 
                    (df['Deduction Submission Date'].dt.date <= prev_end_date)
                )
                prev_period_df = df[prev_mask].copy()
                
                # Previous period metrics
                prev_total = prev_period_df['Amount'].sum() if 'Amount' in prev_period_df.columns and not prev_period_df.empty else 0
                prev_avg = prev_period_df['Amount'].mean() if 'Amount' in prev_period_df.columns and not prev_period_df.empty else 0
                prev_failed = prev_period_df['Failed Amount'].sum() if 'Failed Amount' in prev_period_df.columns and not prev_period_df.empty else 0
                prev_failure_rate = (prev_failed / prev_total * 100) if prev_total > 0 else 0
                prev_transactions = len(prev_period_df) if not prev_period_df.empty else 0
                
                # Calculate percent changes
                total_change_pct = ((total_deductions - prev_total) / prev_total * 100) if prev_total > 0 else 0
                avg_change_pct = ((avg_deduction - prev_avg) / prev_avg * 100) if prev_avg > 0 else 0
                failed_change_pct = ((total_failed - prev_failed) / prev_failed * 100) if prev_failed > 0 else 0
                failure_rate_change = failure_rate - prev_failure_rate
                transaction_change_pct = ((total_transactions - prev_transactions) / prev_transactions * 100) if prev_transactions > 0 else 0
            else:
                total_change_pct = 0
                avg_change_pct = 0
                failed_change_pct = 0
                failure_rate_change = 0
                transaction_change_pct = 0
            
            # Modern metrics panel
            st.markdown("""
            <div class="chart-container">
                <div class="chart-title">📊 Key Performance Metrics</div>
            </div>
            """, unsafe_allow_html=True)
            
            # Create a more modern metrics display with grid layout
            st.markdown("""
            <style>
            .metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 16px;
                margin-bottom: 24px;
            }
            
            .metric-card {
                background-color: white;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                display: flex;
                flex-direction: column;
            }
            
            .metric-header {
                padding: 12px 16px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                border-bottom: 1px solid #f5f5f5;
            }
            
            .metric-title {
                font-size: 0.9rem;
                font-weight: 500;
                color: #616161;
            }
            
            .metric-icon {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
            }
            
            .metric-body {
                padding: 16px;
                display: flex;
                flex-direction: column;
            }
            
            .metric-value {
                font-size: 24px;
                font-weight: 700;
                margin-bottom: 8px;
            }
            
            .metric-comparison {
                font-size: 13px;
                display: flex;
                align-items: center;
            }
            
            .metric-trend {
                display: inline-flex;
                align-items: center;
                padding: 3px 8px;
                border-radius: 12px;
                margin-right: 8px;
                font-weight: 500;
            }
            
            .metric-trend.positive {
                background-color: rgba(76, 175, 80, 0.1);
                color: #4CAF50;
            }
            
            .metric-trend.negative {
                background-color: rgba(244, 67, 54, 0.1);
                color: #F44336;
            }
            
            .metric-progress {
                height: 6px;
                background-color: #f5f5f5;
                border-radius: 3px;
                margin-top: 12px;
                overflow: hidden;
            }
            
            .metric-progress-bar {
                height: 100%;
                border-radius: 3px;
            }
            </style>
            """, unsafe_allow_html=True)
            
            # Calculate class and icon values outside of HTML
            total_trend_class = "positive" if total_change_pct >= 0 else "negative"
            total_trend_icon = "↑" if total_change_pct >= 0 else "↓"
            total_trend_display = f"{abs(total_change_pct):.1f}%"
            
            failed_trend_class = "negative" if failed_change_pct > 0 else "positive"
            failed_trend_icon = "↑" if failed_change_pct > 0 else "↓"
            failed_trend_display = f"{abs(failed_change_pct):.1f}%"
            
            avg_trend_class = "positive" if avg_change_pct >= 0 else "negative"
            avg_trend_icon = "↑" if avg_change_pct >= 0 else "↓"
            avg_trend_display = f"{abs(avg_change_pct):.1f}%"
            
            txn_trend_class = "positive" if transaction_change_pct >= 0 else "negative"
            txn_trend_icon = "↑" if transaction_change_pct >= 0 else "↓"
            txn_trend_display = f"{abs(transaction_change_pct):.1f}%"
            
            failure_trend_class = "positive" if failure_rate_change <= 0 else "negative"
            failure_trend_icon = "↓" if failure_rate_change <= 0 else "↑"
            failure_trend_display = f"{abs(failure_rate_change):.1f}%"
            
            total_formatted = f"${total_deductions:,.2f}"
            failed_formatted = f"${total_failed:,.2f}"
            avg_formatted = f"${avg_deduction:,.2f}"
            txn_formatted = f"{total_transactions:,}"
            success_formatted = f"{success_rate:.1f}%"
            failure_formatted = f"{failure_rate:.1f}%"
            
            # Key Performance Metrics section header
            st.markdown("<h3 style='margin-top:20px; margin-bottom:20px; color:#1E88E5;'>Key Performance Metrics</h3>", unsafe_allow_html=True)
            
            # Create individual metric cards
            col1, col2, col3 = st.columns(3)
            col4, col5, col6 = st.columns(3)
            
            # Display metrics in a 3x2 grid using st.markdown for each card separately
            with col1:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(33, 150, 243, 0.1);">
                        <div class="metric-title">Total Deductions</div>
                        <div class="metric-icon" style="background-color: rgba(33, 150, 243, 0.2); color: #2196F3;">💰</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #2196F3;">{total_formatted}</div>
                        <div class="metric-comparison">
                            <div class="metric-trend {total_trend_class}">
                                {total_trend_icon} {total_trend_display}
                            </div>
                            <span style="color: #757575;">vs previous period</span>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(244, 67, 54, 0.1);">
                        <div class="metric-title">Failed Amount</div>
                        <div class="metric-icon" style="background-color: rgba(244, 67, 54, 0.2); color: #F44336;">⚠️</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #F44336;">{failed_formatted}</div>
                        <div class="metric-comparison">
                            <div class="metric-trend {failed_trend_class}">
                                {failed_trend_icon} {failed_trend_display}
                            </div>
                            <span style="color: #757575;">vs previous period</span>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            with col3:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(255, 152, 0, 0.1);">
                        <div class="metric-title">Average Deduction</div>
                        <div class="metric-icon" style="background-color: rgba(255, 152, 0, 0.2); color: #FF9800;">📏</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #FF9800;">{avg_formatted}</div>
                        <div class="metric-comparison">
                            <div class="metric-trend {avg_trend_class}">
                                {avg_trend_icon} {avg_trend_display}
                            </div>
                            <span style="color: #757575;">vs previous period</span>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            with col4:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(156, 39, 176, 0.1);">
                        <div class="metric-title">Transaction Count</div>
                        <div class="metric-icon" style="background-color: rgba(156, 39, 176, 0.2); color: #9C27B0;">📊</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #9C27B0;">{txn_formatted}</div>
                        <div class="metric-comparison">
                            <div class="metric-trend {txn_trend_class}">
                                {txn_trend_icon} {txn_trend_display}
                            </div>
                            <span style="color: #757575;">vs previous period</span>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            with col5:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(76, 175, 80, 0.1);">
                        <div class="metric-title">Success Rate</div>
                        <div class="metric-icon" style="background-color: rgba(76, 175, 80, 0.2); color: #4CAF50;">✅</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #4CAF50;">{success_formatted}</div>
                        <div class="metric-progress">
                            <div class="metric-progress-bar" style="width: {success_rate}%; background-color: #4CAF50;"></div>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            with col6:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-header" style="background-color: rgba(244, 67, 54, 0.1);">
                        <div class="metric-title">Failure Rate</div>
                        <div class="metric-icon" style="background-color: rgba(244, 67, 54, 0.2); color: #F44336;">❌</div>
                    </div>
                    <div class="metric-body">
                        <div class="metric-value" style="color: #F44336;">{failure_formatted}</div>
                        <div class="metric-comparison">
                            <div class="metric-trend {failure_trend_class}">
                                {failure_trend_icon} {failure_trend_display}
                            </div>
                            <span style="color: #757575;">vs previous period</span>
                        </div>
                        <div class="metric-progress">
                            <div class="metric-progress-bar" style="width: {failure_rate}%; background-color: #F44336;"></div>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            # Modern charts section header and CSS
            st.markdown("""
            <style>
            .chart-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
                margin-bottom: 30px;
            }
            
            .chart-card {
                background-color: white;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                display: flex;
                flex-direction: column;
            }
            
            .chart-header {
                padding: 12px 16px;
                border-bottom: 1px solid #f5f5f5;
                display: flex;
                align-items: center;
            }
            
            .chart-title-text {
                font-size: 0.95rem;
                font-weight: 500;
                color: #424242;
                margin-left: 8px;
            }
            
            .chart-body {
                padding: 15px;
                flex-grow: 1;
                display: flex;
                flex-direction: column;
            }
            
            .chart-content {
                padding: 5px;
                height: 100%;
            }
            
            .chart-tabs .stTabs {
                background-color: white;
                border-radius: 8px;
                padding: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            
            .chart-tabs .stTabs > div:first-child {
                background-color: #f5f5f5;
                border-radius: 5px;
            }
            
            .provider-table {
                margin-top: 10px;
                border-collapse: collapse;
                width: 100%;
            }
            
            .provider-table th {
                background-color: #f5f5f5;
                padding: 8px;
                text-align: left;
                border-bottom: 1px solid #ddd;
                font-weight: 500;
            }
            
            .provider-table td {
                padding: 8px;
                border-bottom: 1px solid #f5f5f5;
            }
            
            @media (max-width: 768px) {
                .chart-grid {
                    grid-template-columns: 1fr;
                }
            }
            </style>
            """, unsafe_allow_html=True)
            
            # Apply additional chart styling
            
            # Use Streamlit's native card styling for charts
            st.markdown("""
            <style>
            .chart-container {
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
                overflow: hidden;
            }
            .chart-header {
                padding: 12px 15px;
                font-weight: 600;
                font-size: 1.1rem;
                border-bottom: 1px solid #f0f0f0;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .chart-content {
                padding: 10px;
            }
            </style>
            """, unsafe_allow_html=True)
            
            # Create section header for visualizations
            st.markdown("<h3 style='margin-top: 30px; margin-bottom: 15px; color: #2196F3;'>📈 Visualization Insights</h3>", unsafe_allow_html=True)
            
            # Use native Streamlit containers for charts
            trend_col, status_col = st.columns(2)
            
            # Trend Analysis Chart
            with trend_col:
                st.markdown("#### 📈 Deductions Trend Analysis")
                if 'Deduction Submission Date' in filtered_df.columns and 'Amount' in filtered_df.columns:
                    # Daily, weekly, monthly aggregation
                    freq = st.radio("View by:", ["Daily", "Weekly", "Monthly"], horizontal=True, key="freq_radio")
                    freq_map = {"Daily": "D", "Weekly": "W-Mon", "Monthly": "M"}
                    
                    time_series = filtered_df.groupby(
                        pd.Grouper(key='Deduction Submission Date', freq=freq_map[freq])
                    )['Amount'].sum().reset_index()
                    
                    # Calculate moving average based on frequency
                    window = 4 if freq == "Monthly" else (2 if freq == "Weekly" else 7)
                    
                    # Create enhanced figure
                    fig = px.area(
                        time_series, 
                        x='Deduction Submission Date', 
                        y='Amount',
                        labels={'Amount': 'Total Amount ($)', 'Deduction Submission Date': 'Date'}
                    )
                    
                    # Enhance area plot
                    fig.update_traces(
                        line=dict(color='#2196F3', width=2),
                        fillcolor='rgba(33, 150, 243, 0.1)'
                    )
                    
                    # Add trendline
                    fig.add_scatter(
                        x=time_series['Deduction Submission Date'],
                        y=time_series['Amount'].rolling(window=min(window, len(time_series)), min_periods=1).mean(),
                        mode='lines',
                        name=f'{window}-Period Moving Avg',
                        line=dict(color='#E91E63', width=2, dash='dash')
                    )
                    
                    fig.update_layout(
                        hovermode='x unified',
                        showlegend=True,
                        xaxis_title=None,
                        yaxis_title='Amount ($)',
                        height=350,
                        paper_bgcolor='rgba(0,0,0,0)',
                        plot_bgcolor='rgba(0,0,0,0)',
                        margin=dict(l=10, r=10, t=10, b=10),
                        legend=dict(
                            orientation='h',
                            yanchor='top',
                            y=-0.15,
                            xanchor='center',
                            x=0.5
                        ),
                        xaxis=dict(
                            gridcolor='#f5f5f5',
                            showline=True,
                            linewidth=1,
                            linecolor='#e0e0e0'
                        ),
                        yaxis=dict(
                            gridcolor='#f5f5f5',
                            showline=True,
                            linewidth=1,
                            linecolor='#e0e0e0'
                        )
                    )
                    st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False})
                else:
                    st.markdown("""
                    <div style="height: 350px; display: flex; align-items: center; justify-content: center; color: #757575; background-color: #f9f9f9; border-radius: 8px;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                            <div>Date or Amount columns not found in data</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                
            # Status & Provider Card
            with status_col:
                st.markdown("#### 🔄 Deductions by Status & Provider")
                
                if all(col in filtered_df.columns for col in ['Status', 'Amount', 'Provider']):
                    # Create a multi-level pie chart
                    tab1, tab2 = st.tabs(["By Status", "By Provider"])
                    
                    with tab1:
                        status_summary = filtered_df.groupby('Status')['Amount'].sum().reset_index()
                        
                        # Enhanced pie chart
                        fig2a = px.pie(
                            status_summary, 
                            values='Amount', 
                            names='Status',
                            hole=0.5,
                            color='Status',
                            color_discrete_map={
                                'Successful': '#4CAF50',
                                'Failed': '#F44336',
                                'Pending': '#FF9800'
                            }
                        )
                        
                        fig2a.update_layout(
                            showlegend=True,
                            margin=dict(l=10, r=10, t=10, b=10),
                            height=350,
                            paper_bgcolor='rgba(0,0,0,0)',
                            plot_bgcolor='rgba(0,0,0,0)',
                            legend=dict(
                                orientation='h',
                                yanchor='bottom',
                                y=-0.15,
                                xanchor='center',
                                x=0.5
                            )
                        )
                        
                        fig2a.update_traces(
                            textinfo='percent+label',
                            hoverinfo='label+value+percent',
                            textposition='inside',
                            textfont_size=12
                        )
                        
                        # Add annotation in the center
                        total_amount = status_summary['Amount'].sum()
                        fig2a.add_annotation(
                            text=f"<b>${total_amount:,.0f}</b><br>Total",
                            x=0.5, y=0.5,
                            font=dict(size=14, color='#424242'),
                            showarrow=False
                        )
                        
                        st.plotly_chart(fig2a, use_container_width=True, config={'displayModeBar': False})
                    
                    with tab2:
                        # Enhanced provider summary
                        provider_summary = filtered_df.groupby('Provider')['Amount'].agg(['sum', 'count'])\
                            .nlargest(10, 'sum')\
                            .reset_index()
                        
                        # Modern HTML table for provider summary
                        html_table = """<table class="provider-table">
                            <thead>
                                <tr>
                                    <th style="width: 50%;">Provider</th>
                                    <th style="width: 30%;">Total Amount</th>
                                    <th style="width: 20%;">Count</th>
                                </tr>
                            </thead>
                            <tbody>
                        """
                        
                        for _, row in provider_summary.iterrows():
                            html_table += f"""<tr>
                                <td>{row['Provider']}</td>
                                <td>${row['sum']:,.2f}</td>
                                <td>{row['count']:,}</td>
                            </tr>"""
                        
                        html_table += """</tbody></table>"""
                        
                        st.markdown(html_table, unsafe_allow_html=True)
                        
                        # Enhanced bar chart
                        top_5_providers = provider_summary.head(5).sort_values('sum')
                
                        fig2b = px.bar(
                            top_5_providers,
                            x='sum',
                            y='Provider',
                            orientation='h',
                            text='sum',
                            color='sum',
                            color_continuous_scale=['#64B5F6', '#2196F3', '#1976D2', '#0D47A1'],
                            labels={'sum': 'Total Amount ($)', 'Provider': ''}
                        )
                        
                        fig2b.update_layout(
                            showlegend=False,
                            margin=dict(l=10, r=10, t=10, b=10),
                            height=220,
                            paper_bgcolor='rgba(0,0,0,0)',
                            plot_bgcolor='rgba(0,0,0,0)',
                            xaxis=dict(title='Total Amount ($)', showgrid=True, gridcolor='#f5f5f5'),
                            yaxis=dict(showgrid=False),
                            coloraxis_showscale=False
                        )
                        
                        fig2b.update_traces(
                            texttemplate='${x:,.0f}',
                            textposition='outside',
                            hovertemplate='<b>%{y}</b><br>Amount: $%{x:,.2f}<extra></extra>',
                            marker_line_width=0
                        )
                        
                        st.plotly_chart(fig2b, use_container_width=True, config={'displayModeBar': False})
                else:
                    st.markdown("""
                    <div style="height: 350px; display: flex; align-items: center; justify-content: center; color: #757575; background-color: #f9f9f9; border-radius: 8px;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                            <div>Status or Provider data not found</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
            # Top Employers section with modern styling
            st.markdown("<h3 style='margin-top: 30px; margin-bottom: 15px; color: #673AB7;'>🏢 Top Employers Analysis</h3>", unsafe_allow_html=True)
            
            # Use a standard Streamlit header instead of HTML card
            st.markdown("#### 🏢 Top Employers by Deduction Amount")
            
            if 'Employer' in filtered_df.columns and 'Amount' in filtered_df.columns:
                # Sort employers by amount for better visualization
                top_employers = filtered_df.groupby('Employer')['Amount'].sum().nlargest(10).reset_index()
                top_employers = top_employers.sort_values('Amount')
                
                # Add count information
                employer_counts = filtered_df.groupby('Employer').size().reset_index(name='count')
                top_employers = top_employers.merge(employer_counts, on='Employer', how='left')
                
                # Create enhanced horizontal bar chart
                fig = px.bar(
                    top_employers,
                    x='Amount',
                    y='Employer',
                    orientation='h',
                    text='Amount',
                    color='Amount',
                    color_continuous_scale=['#B39DDB', '#9575CD', '#7E57C2', '#673AB7', '#5E35B1', '#4527A0'],
                    labels={'Amount': 'Total Amount ($)', 'Employer': ''}
                )
                
                # Enhanced hover information
                hover_template = '<b>%{y}</b><br>Total: $%{x:,.2f}<br>Transactions: %{customdata}<extra></extra>'
                fig.update_traces(
                    customdata=top_employers['count'],
                    texttemplate='$%{x:,.0f}',
                    textposition='outside',
                    hovertemplate=hover_template,
                    marker_line_width=0
                )
                
                # Modern layout
                fig.update_layout(
                    xaxis_title='Total Amount ($)',
                    height=450,
                    coloraxis_showscale=False,
                    paper_bgcolor='rgba(0,0,0,0)',
                    plot_bgcolor='rgba(0,0,0,0)',
                    margin=dict(l=10, r=20, t=10, b=10),
                    xaxis=dict(
                        gridcolor='#f5f5f5',
                        showline=True,
                        linewidth=1,
                        linecolor='#e0e0e0'
                    ),
                    yaxis=dict(
                        categoryorder='total ascending',
                        gridcolor='#f5f5f5',
                        showline=False
                    )
                )
                
                # Add summary annotation
                total_employer_amount = top_employers['Amount'].sum()
                total_employer_count = top_employers['count'].sum()
                fig.add_annotation(
                    text=f"Top 10 employers represent<br>${total_employer_amount:,.0f} in {total_employer_count:,} transactions",
                    align="right",
                    xref="paper", yref="paper",
                    x=0.98, y=0.98,
                    showarrow=False,
                    font=dict(size=12, color="#424242"),
                    bgcolor="rgba(255, 255, 255, 0.8)",
                    bordercolor="#e0e0e0",
                    borderwidth=1,
                    borderpad=4,
                    opacity=0.8
                )
                
                st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False})
                
                # Add summary metrics in a modern row with Streamlit columns
                total_employers = filtered_df['Employer'].nunique()
                avg_per_employer = filtered_df.groupby('Employer')['Amount'].mean().mean()
                median_txn = filtered_df.groupby('Employer').size().median()
                
                # Add necessary CSS for summary metrics styling
                st.markdown("""
                <style>
                .employer-metric {
                    background-color: white;
                    border-radius: 8px;
                    padding: 16px;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
                    display: flex;
                    align-items: center;
                    height: 100%;
                }
                .employer-icon {
                    width: 40px;
                    height: 40px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin-right: 16px;
                    font-size: 20px;
                }
                .employer-content {
                    display: flex;
                    flex-direction: column;
                }
                .employer-value {
                    font-size: 18px;
                    font-weight: 600;
                    color: #212121;
                }
                .employer-label {
                    font-size: 13px;
                    color: #757575;
                    margin-top: 4px;
                }
                </style>
                """, unsafe_allow_html=True)
                
                # Create a row of metrics using columns
                col1, col2, col3 = st.columns(3)
                
                # Metric 1: Unique Employers
                with col1:
                    st.markdown(f"""
                    <div class="employer-metric">
                        <div class="employer-icon" style="background-color: rgba(103, 58, 183, 0.1); color: #673AB7;">
                            🏢
                        </div>
                        <div class="employer-content">
                            <div class="employer-value">{total_employers:,}</div>
                            <div class="employer-label">Unique Employers</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                
                # Metric 2: Average per Employer
                with col2:
                    st.markdown(f"""
                    <div class="employer-metric">
                        <div class="employer-icon" style="background-color: rgba(33, 150, 243, 0.1); color: #2196F3;">
                            💰
                        </div>
                        <div class="employer-content">
                            <div class="employer-value">${avg_per_employer:,.2f}</div>
                            <div class="employer-label">Average per Employer</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                
                # Metric 3: Median Transactions
                with col3:
                    st.markdown(f"""
                    <div class="employer-metric">
                        <div class="employer-icon" style="background-color: rgba(76, 175, 80, 0.1); color: #4CAF50;">
                            📊
                        </div>
                        <div class="employer-content">
                            <div class="employer-value">{median_txn:.1f}</div>
                            <div class="employer-label">Median Transactions</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
            
            else:
                st.markdown("""
                <div style="height: 350px; display: flex; align-items: center; justify-content: center; color: #757575; background-color: #f9f9f9; border-radius: 8px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                        <div>Employer or Amount columns not found in data</div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            # Removed Provider Performance section - moved to Transaction Explorer tab
        
        with tab2:
            st.markdown("</div>", unsafe_allow_html=True)
            st.markdown("<div class='dashboard-section'>", unsafe_allow_html=True)
            st.markdown("<h3 class='sub-title'>🔍 Transaction Explorer</h3>", unsafe_allow_html=True)
            
            # Check if we need to refresh the explorer view
            if st.session_state.get('force_explorer_refresh', False):
                st.session_state.force_explorer_refresh = False
                st.experimental_rerun()
            
            # Check if we have a provider filter from the Overview tab
            if st.session_state.selected_provider:
                st.info(f"Showing transactions for provider: {st.session_state.selected_provider}")
                if st.button("Clear filter"):
                    st.session_state.selected_provider = None
                    st.experimental_rerun()
                    
            # Display transaction explorer content
            if df.empty:
                st.warning("No transaction data available. Please upload a file first.")
                return
            
            # Transaction Explorer content starts here (Provider Analysis section removed)
                
            # Add filters
            st.markdown("<div class='filter-container'>", unsafe_allow_html=True)
            st.markdown("<h4 class='sub-title'>🔎 Filters</h4>", unsafe_allow_html=True)
            col1, col2, col3 = st.columns(3)
            
            with col1:
                status_options = df['Status'].unique() if 'Status' in df.columns else []
                status_filter = st.multiselect(
                    "Status",
                    options=status_options,
                    default=[]
                )
            
            with col2:
                provider_options = df['Provider'].unique() if 'Provider' in df.columns else []
                # If we have a selected provider from the Overview tab, use it as the default
                default_provider = [st.session_state.selected_provider] if st.session_state.selected_provider else []
                provider_filter = st.multiselect(
                    "Provider",
                    options=provider_options,
                    default=default_provider
                )
            
            with col3:
                min_amt = float(df['Amount'].min()) if 'Amount' in df.columns else 0
                max_amt = float(df['Amount'].max()) if 'Amount' in df.columns else 1000
                min_amount, max_amount = st.slider(
                    "Deduction Amount Range",
                    min_value=min_amt,
                    max_value=max_amt,
                    value=(min_amt, max_amt)
                )
            
            # Apply filters
            filtered_data = df.copy()
            if status_filter:
                filtered_data = filtered_data[filtered_data['Status'].isin(status_filter)]
            if provider_filter:
                filtered_data = filtered_data[filtered_data['Provider'].isin(provider_filter)]
            if 'Amount' in filtered_data.columns:
                filtered_data = filtered_data[
                    (filtered_data['Amount'] >= min_amount) & 
                    (filtered_data['Amount'] <= max_amount)
                ]
            
            # Show metrics for the filtered data
            if not filtered_data.empty:
                st.metric("Total Transactions", len(filtered_data))
                st.metric("Total Amount", f"${filtered_data['Amount'].sum():,.2f}" if 'Amount' in filtered_data.columns else "N/A")
            
            # Sorting options
            st.markdown("</div>", unsafe_allow_html=True)
            st.markdown("<h4 class='sub-title'>⏱️ Sort & Pagination</h4>", unsafe_allow_html=True)
            col1, col2 = st.columns(2)
            
            with col1:
                sort_by = st.selectbox(
                    "Sort by",
                    ['Deduction Submission Date', 'Amount', 'Status', 'Provider'],
                    index=0
                )
            
            with col2:
                sort_order = st.radio("Sort order", ["Descending", "Ascending"], horizontal=True)
            
            filtered_data = filtered_data.sort_values(
                by=sort_by,
                ascending=(sort_order == "Ascending"),
                na_position='last'
            )
            
            # Display data table with pagination
            if not filtered_data.empty:
                page_size = 10
                total_pages = (len(filtered_data) // page_size) + (1 if len(filtered_data) % page_size > 0 else 0)
                page_number = st.number_input("Page", min_value=1, max_value=max(total_pages, 1), value=1)
                start_idx = (page_number - 1) * page_size
                end_idx = start_idx + page_size
                
                # Display the current page of data
                st.dataframe(
                    filtered_data.iloc[start_idx:end_idx],
                    use_container_width=True,
                    hide_index=True
                )
                
                # Add export button
                csv = filtered_data.to_csv(index=False).encode('utf-8')
                st.download_button(
                    "Export Filtered Data",
                    data=csv,
                    file_name=f"deductions_export_{datetime.datetime.now().strftime('%Y%m%d')}.csv",
                    mime='text/csv',
                    key='download_csv',
                    use_container_width=True
                )
            else:
                st.warning("No data matches the selected filters.")
            
            # Clear the selected provider after displaying
            if st.session_state.selected_provider:
                st.session_state.selected_provider = None
        
        with tab3:
            st.markdown("</div>", unsafe_allow_html=True)
            st.markdown("<div class='dashboard-section'>", unsafe_allow_html=True)
            st.markdown("<h3 class='sub-title'>📈 Advanced Analytics</h3>", unsafe_allow_html=True)
            
            # Performance Metrics
            st.markdown("<h4 class='sub-title'>⚡ Performance Metrics</h4>", unsafe_allow_html=True)
            col1, col2, col3 = st.columns(3)
            
            with col1:
                # Success rate by provider
                if all(col in df.columns for col in ['Provider', 'Status', 'Amount']):
                    provider_perf = df.groupby('Provider').agg(
                        total_amount=('Amount', 'sum'),
                        success_rate=('Status', lambda x: (x == 'Successful').mean() * 100),
                        avg_amount=('Amount', 'mean')
                    ).reset_index()
                    
                    st.metric("Top Performing Provider", 
                             provider_perf.nlargest(1, 'total_amount')['Provider'].values[0] if not provider_perf.empty else "N/A",
                             f"${provider_perf['total_amount'].max():,.2f}" if not provider_perf.empty else "$0.00")
            
            with col2:
                if not provider_perf.empty:
                    avg_success_rate = provider_perf['success_rate'].mean()
                    st.metric("Average Success Rate", f"{avg_success_rate:.1f}%")
            
            with col3:
                if 'Failed Amount' in df.columns:
                    recovery_rate = (1 - (df['Failed Amount'].sum() / df['Amount'].sum())) * 100
                    st.metric("Recovery Rate", f"{recovery_rate:.1f}%")
            
            # Time-based analysis
            st.markdown("<h4 class='sub-title'>⏰ Time-Based Analysis</h4>", unsafe_allow_html=True)
            
            if 'Deduction Submission Date' in df.columns and 'Amount' in df.columns:
                # Weekly patterns
                df['DayOfWeek'] = df['Deduction Submission Date'].dt.day_name()
                df['Hour'] = df['Deduction Submission Date'].dt.hour
                
                # Day of week analysis
                day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
                weekly_pattern = df.groupby('DayOfWeek')['Amount'].sum().reindex(day_order).reset_index()
                
                fig_weekly = px.bar(
                    weekly_pattern,
                    x='DayOfWeek',
                    y='Amount',
                    title='Deduction Amount by Day of Week',
                    labels={'Amount': 'Total Amount ($)', 'DayOfWeek': 'Day of Week'},
                    template='plotly_white'
                )
                
                # Hourly pattern
                hourly_pattern = df.groupby('Hour')['Amount'].sum().reset_index()
                
                fig_hourly = px.line(
                    hourly_pattern,
                    x='Hour',
                    y='Amount',
                    title='Deduction Amount by Hour of Day',
                    labels={'Amount': 'Total Amount ($)', 'Hour': 'Hour of Day'},
                    template='plotly_white',
                    markers=True
                )
                
                # Display charts
                col1, col2 = st.columns(2)
                with col1:
                    st.plotly_chart(fig_weekly, use_container_width=True)
                with col2:
                    st.plotly_chart(fig_hourly, use_container_width=True)
            
            # Provider Performance
            st.markdown("<h4 class='sub-title'>🏆 Provider Performance</h4>", unsafe_allow_html=True)
            
            if all(col in df.columns for col in ['Provider', 'Status', 'Amount']):
                # Top 10 providers by amount
                top_providers = df.groupby('Provider').agg(
                    total_amount=('Amount', 'sum'),
                    success_rate=('Status', lambda x: (x == 'Successful').mean() * 100),
                    avg_amount=('Amount', 'mean'),
                    count=('Amount', 'count')
                ).nlargest(10, 'total_amount').reset_index()
                
                # Create a bar chart with success rate as line
                fig_providers = go.Figure()
                
                # Bar chart for total amount
                fig_providers.add_trace(
                    go.Bar(
                        x=top_providers['Provider'],
                        y=top_providers['total_amount'],
                        name='Total Amount',
                        marker_color='#1f77b4'
                    )
                )
                
                # Line chart for success rate (secondary y-axis)
                fig_providers.add_trace(
                    go.Scatter(
                        x=top_providers['Provider'],
                        y=top_providers['success_rate'],
                        name='Success Rate %',
                        yaxis='y2',
                        line=dict(color='#ff7f0e', width=2)
                    )
                )
                
                # Update layout for dual y-axes
                fig_providers.update_layout(
                    title='Top 10 Providers by Deduction Amount',
                    xaxis_title='Provider',
                    yaxis_title='Total Amount ($)',
                    yaxis2=dict(
                        title='Success Rate (%)',
                        overlaying='y',
                        side='right',
                        range=[0, 100]  # Percentage range
                    ),
                    legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1),
                    template='plotly_white'
                )
                
                st.plotly_chart(fig_providers, use_container_width=True)
                
                # Show provider performance table
                st.markdown("**Provider Performance Metrics**")
                st.dataframe(
                    top_providers.rename(columns={
                        'total_amount': 'Total Amount ($)',
                        'success_rate': 'Success Rate (%)',
                        'avg_amount': 'Avg. Amount ($)',
                        'count': 'Transaction Count'
                    }),
                    use_container_width=True,
                    hide_index=True
                )
            
            # Time Series Analysis Section
            st.markdown("<h4 class='sub-title'>📊 Time Series Analysis</h4>", unsafe_allow_html=True)
            
            if 'Deduction Submission Date' in df.columns and 'Amount' in df.columns:
                # Resample data by week
                time_series = df.set_index('Deduction Submission Date')['Amount'].resample('W').sum().reset_index()
                
                # Calculate moving averages
                time_series['7D_MA'] = time_series['Amount'].rolling(window=4, min_periods=1).mean()
                time_series['30D_MA'] = time_series['Amount'].rolling(window=12, min_periods=1).mean()
                
                # Create the time series chart
                fig = go.Figure()
                
                # Add actual values
                fig.add_trace(go.Scatter(
                    x=time_series['Deduction Submission Date'],
                    y=time_series['Amount'],
                    mode='lines+markers',
                    name='Weekly Total',
                    line=dict(color='#1f77b4')
                ))
                
                # Add moving averages
                fig.add_trace(go.Scatter(
                    x=time_series['Deduction Submission Date'],
                    y=time_series['7D_MA'],
                    mode='lines',
                    name='4-Week Moving Avg',
                    line=dict(color='#ff7f0e', dash='dash')
                ))
                
                fig.add_trace(go.Scatter(
                    x=time_series['Deduction Submission Date'],
                    y=time_series['30D_MA'],
                    mode='lines',
                    name='12-Week Moving Avg',
                    line=dict(color='#2ca02c', dash='dot')
                ))
                
                fig.update_layout(
                    title='Deduction Amounts Over Time with Moving Averages',
                    xaxis_title='Date',
                    yaxis_title='Amount ($)',
                    hovermode='x unified',
                    height=500
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Anomaly Detection
                st.markdown("### Anomaly Detection")
                
                # Simple Z-score based anomaly detection
                time_series['zscore'] = (time_series['Amount'] - time_series['Amount'].mean()) / time_series['Amount'].std()
                anomalies = time_series[abs(time_series['zscore']) > 2]
                
                if not anomalies.empty:
                    st.warning(f"⚠️ Detected {len(anomalies)} potential anomalies in the data")
                    
                    # Create anomaly chart
                    anomaly_fig = go.Figure()
                    
                    # Add normal points
                    normal = time_series[abs(time_series['zscore']) <= 2]
                    anomaly_fig.add_trace(go.Scatter(
                        x=normal['Deduction Submission Date'],
                        y=normal['Amount'],
                        mode='markers',
                        name='Normal',
                        marker=dict(color='blue')
                    ))
                    
                    # Add anomalies
                    anomaly_fig.add_trace(go.Scatter(
                        x=anomalies['Deduction Submission Date'],
                        y=anomalies['Amount'],
                        mode='markers',
                        name='Anomaly',
                        marker=dict(color='red', size=10, line=dict(width=2, color='DarkRed'))
                    ))
                    
                    anomaly_fig.update_layout(
                        title='Detected Anomalies in Deduction Amounts',
                        xaxis_title='Date',
                        yaxis_title='Amount ($)',
                        height=400
                    )
                    
                    st.plotly_chart(anomaly_fig, use_container_width=True)
                    
                    # Show anomaly details
                    with st.expander("View Anomaly Details"):
                        anomaly_display = anomalies[['Deduction Submission Date', 'Amount', 'zscore']].copy()
                        anomaly_display['Deviation'] = (anomaly_display['zscore'].abs() * 100).round(2).astype(str) + '% from mean'
                        anomaly_display = anomaly_display.rename(columns={
                            'Deduction Submission Date': 'Date',
                            'Amount': 'Deduction Amount',
                            'zscore': 'Z-Score'
                        })
                        st.dataframe(anomaly_display, hide_index=True, use_container_width=True)
                else:
                    st.success("✅ No significant anomalies detected in the data")
            
            # Correlation Analysis
            st.markdown("### Correlation Analysis")
            
            if len(df.select_dtypes(include=['number']).columns) > 1:
                # Select numeric columns for correlation
                numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
                
                if len(numeric_cols) >= 2:
                    # Calculate correlation matrix
                    corr = df[numeric_cols].corr()
                    
                    # Create heatmap
                    fig = px.imshow(
                        corr,
                        text_auto=True,
                        aspect="auto",
                        color_continuous_scale='RdBu',
                        zmin=-1,
                        zmax=1,
                        title='Correlation Matrix of Numeric Variables'
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Show top correlations
                    st.markdown("#### Top Correlations")
                    
                    # Get upper triangle of correlation matrix
                    corr = corr.mask(np.triu(np.ones_like(corr, dtype=bool)))
                    
                    # Unstack and sort correlations
                    corr_pairs = corr.unstack().sort_values(ascending=False)
                    
                    # Create a DataFrame of correlations
                    corr_df = pd.DataFrame(corr_pairs, columns=['Correlation']).reset_index()
                    corr_df = corr_df[corr_df['Correlation'] != 1]  # Remove self-correlations
                    corr_df = corr_df.dropna()
                    
                    if not corr_df.empty:
                        top_correlations = corr_df.head(10)
                        
                        # Create a bar chart of top correlations
                        fig = px.bar(
                            top_correlations,
                            x='Correlation',
                            y=top_correlations['level_0'] + ' & ' + top_correlations['level_1'],
                            orientation='h',
                            title='Top Variable Correlations',
                            labels={'Correlation': 'Correlation Coefficient', 'y': 'Variable Pairs'}
                        )
                        
                        fig.update_layout(yaxis={'categoryorder':'total ascending'}, height=400)
                        st.plotly_chart(fig, use_container_width=True)
                    else:
                        st.info("No significant correlations found between numeric variables.")
                else:
                    st.warning("Need at least two numeric columns for correlation analysis.")
            else:
                st.warning("Not enough numeric data for correlation analysis.")
            
            # Advanced Filtering
            st.markdown("### Advanced Data Exploration")
            
            # Dynamic filters
            st.markdown("#### Apply Filters")
            
            filter_cols = st.columns(3)
            filters = {}
            
            # Get unique values for filtering
            categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()
            numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
            
            # Add categorical filters
            for i, col in enumerate(categorical_cols[:3]):  # Show first 3 categorical columns
                with filter_cols[i % 3]:
                    unique_vals = df[col].unique().tolist()
                    if len(unique_vals) > 1:  # Only show if there's more than one unique value
                        selected = st.multiselect(f"Filter by {col}", options=unique_vals, key=f"filter_{col}")
                        if selected:
                            filters[col] = selected
            
            # Add numeric range filters
            st.markdown("#### Numeric Ranges")
            range_cols = st.columns(2)
            
            for i, col in enumerate(numeric_cols[:4]):  # Show first 4 numeric columns
                with range_cols[i % 2]:
                    min_val = float(df[col].min())
                    max_val = float(df[col].max())
                    
                    # Create a range slider
                    values = st.slider(
                        f"{col} Range",
                        min_value=min_val,
                        max_value=max_val,
                        value=(min_val, max_val),
                        key=f"range_{col}"
                    )
                    
                    filters[f"{col}_min"] = values[0]
                    filters[f"{col}_max"] = values[1]
            
            # Apply filters
            filtered_df = df.copy()
            
            # Apply categorical filters
            for col, values in filters.items():
                if col in categorical_cols:
                    filtered_df = filtered_df[filtered_df[col].isin(values)]
                elif col.endswith('_min') and col.replace('_min', '') in numeric_cols:
                    col_name = col.replace('_min', '')
                    filtered_df = filtered_df[filtered_df[col_name] >= values]
                elif col.endswith('_max') and col.replace('_max', '') in numeric_cols:
                    col_name = col.replace('_max', '')
                    filtered_df = filtered_df[filtered_df[col_name] <= values]
            
            # Show filtered data
            st.markdown(f"#### Filtered Data ({len(filtered_df)} rows)")
            st.dataframe(filtered_df, use_container_width=True)
            
            # Export filtered data
            st.download_button(
                label="Download Filtered Data (CSV)",
                data=filtered_df.to_csv(index=False).encode('utf-8'),
                file_name='filtered_deductions.csv',
                mime='text/csv',
                key='download_filtered_data'
            )

if __name__ == "__main__":
    main()
